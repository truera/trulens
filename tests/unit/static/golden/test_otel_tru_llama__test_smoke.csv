,record,event_id,record_attributes,record_type,resource_attributes,start_timestamp,timestamp,trace
1,"{'name': 'llama_index.core.base.base_query_engine.BaseQueryEngine.query', 'kind': 1, 'parent_span_id': '', 'status': 'STATUS_CODE_UNSET'}",7523328258905982813,"{'name': 'llama_index.core.base.base_query_engine.BaseQueryEngine.query', 'ai.observability.span_type': 'record_root', 'ai.observability.app_name': 'Simple RAG', 'ai.observability.app_version': 'v1', 'ai.observability.record_id': 'b9c4b5d8-ef47-497e-bab5-8b659f743ed5', 'ai.observability.run.name': 'test run', 'ai.observability.input_id': '42', 'ai.observability.call.return': 'Context information is below.\n---------------------\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].\n\npage_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.\n\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: What is multi-headed attention?\nAnswer: ', 'ai.observability.call.kwargs.str_or_query_bundle': 'What is multi-headed attention?', 'ai.observability.record_root.main_input': 'What is multi-headed attention?', 'ai.observability.record_root.main_output': 'Context information is below.\n---------------------\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].\n\npage_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.\n\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: What is multi-headed attention?\nAnswer: '}",EventRecordType.SPAN,"{'telemetry.sdk.language': 'python', 'telemetry.sdk.name': 'opentelemetry', 'telemetry.sdk.version': '1.30.0', 'service.name': 'trulens'}",2025-02-10 15:24:12.314976,2025-02-10 15:24:12.323933,"{'trace_id': '86007325167544494562106922366787585772', 'parent_id': '', 'span_id': '7523328258905982813'}"
2,"{'name': 'llama_index.core.query_engine.retriever_query_engine.RetrieverQueryEngine.retrieve', 'kind': 1, 'parent_span_id': '7523328258905982813', 'status': 'STATUS_CODE_UNSET'}",16947185492806254910,"{'name': 'llama_index.core.query_engine.retriever_query_engine.RetrieverQueryEngine.retrieve', 'ai.observability.span_type': 'retrieval', 'ai.observability.app_name': 'Simple RAG', 'ai.observability.app_version': 'v1', 'ai.observability.record_id': 'b9c4b5d8-ef47-497e-bab5-8b659f743ed5', 'ai.observability.run.name': 'test run', 'ai.observability.input_id': '42', 'ai.observability.call.return': ['Node ID: 399da470-28ae-4a94-b5f7-7074b6ac7e83\nText: Recent work has achieved significant improvements in\ncomputational efficiency through factorization tricks [21] and\nconditional computation [32], while also improving model performance\nin case of the latter. The fundamental constraint of sequential\ncomputation, however, remains. Attention mechanisms have become an\nintegral part of compelling seq...\nScore:  0.900\n', 'Node ID: b49a9bd9-d3b8-4709-899d-d0a57a083365\nText: To facilitate these residual connections, all sub-layers in the\nmodel, as well as the embedding layers, produce outputs of dimension\ndmodel = 512. Decoder: The decoder is also composed of a stack of N =\n6identical layers. In addition to the two sub-layers in each encoder\nlayer, the decoder inserts a third sub-layer, which performs multi-\nhead att...\nScore:  0.891\n', 'Node ID: 1950b011-54a1-436c-bf0a-ed1b98997414\nText: Recurrent models typically factor computation along the symbol\npositions of the input and output sequences. Aligning the positions to\nsteps in computation time, they generate a sequence of hidden states\nht, as a function of the previous hidden state ht−1 and the input for\nposition t. This inherently sequential nature precludes\nparallelization wi...\nScore:  0.880\n'], 'ai.observability.call.kwargs.query_bundle': 'What is multi-headed attention?', 'ai.observability.retrieval.retrieved_contexts': ['Recent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].', 'To facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.', 'Recurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.'], 'ai.observability.retrieval.query_text': 'What is multi-headed attention?'}",EventRecordType.SPAN,"{'telemetry.sdk.language': 'python', 'telemetry.sdk.name': 'opentelemetry', 'telemetry.sdk.version': '1.30.0', 'service.name': 'trulens'}",2025-02-10 15:24:12.315077,2025-02-10 15:24:12.316293,"{'trace_id': '86007325167544494562106922366787585772', 'parent_id': '7523328258905982813', 'span_id': '16947185492806254910'}"
3,"{'name': 'llama_index.core.base.base_retriever.BaseRetriever.retrieve', 'kind': 1, 'parent_span_id': '16947185492806254910', 'status': 'STATUS_CODE_UNSET'}",16806714151590350495,"{'name': 'llama_index.core.base.base_retriever.BaseRetriever.retrieve', 'ai.observability.span_type': 'retrieval', 'ai.observability.app_name': 'Simple RAG', 'ai.observability.app_version': 'v1', 'ai.observability.record_id': 'b9c4b5d8-ef47-497e-bab5-8b659f743ed5', 'ai.observability.run.name': 'test run', 'ai.observability.input_id': '42', 'ai.observability.call.return': ['Node ID: 399da470-28ae-4a94-b5f7-7074b6ac7e83\nText: Recent work has achieved significant improvements in\ncomputational efficiency through factorization tricks [21] and\nconditional computation [32], while also improving model performance\nin case of the latter. The fundamental constraint of sequential\ncomputation, however, remains. Attention mechanisms have become an\nintegral part of compelling seq...\nScore:  0.900\n', 'Node ID: b49a9bd9-d3b8-4709-899d-d0a57a083365\nText: To facilitate these residual connections, all sub-layers in the\nmodel, as well as the embedding layers, produce outputs of dimension\ndmodel = 512. Decoder: The decoder is also composed of a stack of N =\n6identical layers. In addition to the two sub-layers in each encoder\nlayer, the decoder inserts a third sub-layer, which performs multi-\nhead att...\nScore:  0.891\n', 'Node ID: 1950b011-54a1-436c-bf0a-ed1b98997414\nText: Recurrent models typically factor computation along the symbol\npositions of the input and output sequences. Aligning the positions to\nsteps in computation time, they generate a sequence of hidden states\nht, as a function of the previous hidden state ht−1 and the input for\nposition t. This inherently sequential nature precludes\nparallelization wi...\nScore:  0.880\n'], 'ai.observability.call.kwargs.str_or_query_bundle': 'What is multi-headed attention?', 'ai.observability.retrieval.retrieved_contexts': ['Recent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].', 'To facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.', 'Recurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.'], 'ai.observability.retrieval.query_text': 'What is multi-headed attention?'}",EventRecordType.SPAN,"{'telemetry.sdk.language': 'python', 'telemetry.sdk.name': 'opentelemetry', 'telemetry.sdk.version': '1.30.0', 'service.name': 'trulens'}",2025-02-10 15:24:12.315092,2025-02-10 15:24:12.316127,"{'trace_id': '86007325167544494562106922366787585772', 'parent_id': '16947185492806254910', 'span_id': '16806714151590350495'}"
4,"{'name': 'llama_index.core.indices.vector_store.retrievers.retriever.VectorIndexRetriever._retrieve', 'kind': 1, 'parent_span_id': '16806714151590350495', 'status': 'STATUS_CODE_UNSET'}",17471605131595538324,"{'name': 'llama_index.core.indices.vector_store.retrievers.retriever.VectorIndexRetriever._retrieve', 'ai.observability.span_type': 'retrieval', 'ai.observability.app_name': 'Simple RAG', 'ai.observability.app_version': 'v1', 'ai.observability.record_id': 'b9c4b5d8-ef47-497e-bab5-8b659f743ed5', 'ai.observability.run.name': 'test run', 'ai.observability.input_id': '42', 'ai.observability.call.return': ['Node ID: 399da470-28ae-4a94-b5f7-7074b6ac7e83\nText: Recent work has achieved significant improvements in\ncomputational efficiency through factorization tricks [21] and\nconditional computation [32], while also improving model performance\nin case of the latter. The fundamental constraint of sequential\ncomputation, however, remains. Attention mechanisms have become an\nintegral part of compelling seq...\nScore:  0.900\n', 'Node ID: b49a9bd9-d3b8-4709-899d-d0a57a083365\nText: To facilitate these residual connections, all sub-layers in the\nmodel, as well as the embedding layers, produce outputs of dimension\ndmodel = 512. Decoder: The decoder is also composed of a stack of N =\n6identical layers. In addition to the two sub-layers in each encoder\nlayer, the decoder inserts a third sub-layer, which performs multi-\nhead att...\nScore:  0.891\n', 'Node ID: 1950b011-54a1-436c-bf0a-ed1b98997414\nText: Recurrent models typically factor computation along the symbol\npositions of the input and output sequences. Aligning the positions to\nsteps in computation time, they generate a sequence of hidden states\nht, as a function of the previous hidden state ht−1 and the input for\nposition t. This inherently sequential nature precludes\nparallelization wi...\nScore:  0.880\n'], 'ai.observability.call.kwargs.query_bundle': 'What is multi-headed attention?', 'ai.observability.retrieval.retrieved_contexts': ['Recent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].', 'To facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.', 'Recurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.'], 'ai.observability.retrieval.query_text': 'What is multi-headed attention?'}",EventRecordType.SPAN,"{'telemetry.sdk.language': 'python', 'telemetry.sdk.name': 'opentelemetry', 'telemetry.sdk.version': '1.30.0', 'service.name': 'trulens'}",2025-02-10 15:24:12.315148,2025-02-10 15:24:12.315921,"{'trace_id': '86007325167544494562106922366787585772', 'parent_id': '16806714151590350495', 'span_id': '17471605131595538324'}"
5,"{'name': 'llama_index.core.response_synthesizers.compact_and_refine.CompactAndRefine.get_response', 'kind': 1, 'parent_span_id': '7523328258905982813', 'status': 'STATUS_CODE_UNSET'}",3831804398845421373,"{'name': 'llama_index.core.response_synthesizers.compact_and_refine.CompactAndRefine.get_response', 'ai.observability.span_type': 'unknown', 'ai.observability.app_name': 'Simple RAG', 'ai.observability.app_version': 'v1', 'ai.observability.record_id': 'b9c4b5d8-ef47-497e-bab5-8b659f743ed5', 'ai.observability.run.name': 'test run', 'ai.observability.input_id': '42', 'ai.observability.call.return': 'Context information is below.\n---------------------\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].\n\npage_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.\n\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: What is multi-headed attention?\nAnswer: ', 'ai.observability.call.kwargs.query_str': 'What is multi-headed attention?', 'ai.observability.call.kwargs.text_chunks': ['page_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].', 'page_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.', 'page_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.']}",EventRecordType.SPAN,"{'telemetry.sdk.language': 'python', 'telemetry.sdk.name': 'opentelemetry', 'telemetry.sdk.version': '1.30.0', 'service.name': 'trulens'}",2025-02-10 15:24:12.316371,2025-02-10 15:24:12.323821,"{'trace_id': '86007325167544494562106922366787585772', 'parent_id': '7523328258905982813', 'span_id': '3831804398845421373'}"
6,"{'name': 'llama_index.core.response_synthesizers.refine.Refine.get_response', 'kind': 1, 'parent_span_id': '3831804398845421373', 'status': 'STATUS_CODE_UNSET'}",1619271752053494628,"{'name': 'llama_index.core.response_synthesizers.refine.Refine.get_response', 'ai.observability.span_type': 'unknown', 'ai.observability.app_name': 'Simple RAG', 'ai.observability.app_version': 'v1', 'ai.observability.record_id': 'b9c4b5d8-ef47-497e-bab5-8b659f743ed5', 'ai.observability.run.name': 'test run', 'ai.observability.input_id': '42', 'ai.observability.call.return': 'Context information is below.\n---------------------\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].\n\npage_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.\n\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: What is multi-headed attention?\nAnswer: ', 'ai.observability.call.kwargs.query_str': 'What is multi-headed attention?', 'ai.observability.call.kwargs.text_chunks': ['page_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].\n\npage_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.\n\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.']}",EventRecordType.SPAN,"{'telemetry.sdk.language': 'python', 'telemetry.sdk.name': 'opentelemetry', 'telemetry.sdk.version': '1.30.0', 'service.name': 'trulens'}",2025-02-10 15:24:12.323267,2025-02-10 15:24:12.323792,"{'trace_id': '86007325167544494562106922366787585772', 'parent_id': '3831804398845421373', 'span_id': '1619271752053494628'}"
7,"{'name': 'llama_index.core.llms.mock.MockLLM.complete', 'kind': 1, 'parent_span_id': '1619271752053494628', 'status': 'STATUS_CODE_UNSET'}",3960762505308582189,"{'name': 'llama_index.core.llms.mock.MockLLM.complete', 'ai.observability.span_type': 'unknown', 'ai.observability.app_name': 'Simple RAG', 'ai.observability.app_version': 'v1', 'ai.observability.record_id': 'b9c4b5d8-ef47-497e-bab5-8b659f743ed5', 'ai.observability.run.name': 'test run', 'ai.observability.input_id': '42', 'ai.observability.call.return': 'Context information is below.\n---------------------\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].\n\npage_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.\n\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: What is multi-headed attention?\nAnswer: ', 'ai.observability.call.kwargs.formatted': True, 'ai.observability.call.kwargs.args': ['Context information is below.\n---------------------\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc-\ntion models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19].\n\npage_label: 3\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nTo facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack.\n\npage_label: 2\nfile_path: tests/unit/data/attention_is_all_you_need.pdf\n\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples.\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: What is multi-headed attention?\nAnswer: '], 'ai.observability.call.kwargs.kwargs': ""{'formatted': True}""}",EventRecordType.SPAN,"{'telemetry.sdk.language': 'python', 'telemetry.sdk.name': 'opentelemetry', 'telemetry.sdk.version': '1.30.0', 'service.name': 'trulens'}",2025-02-10 15:24:12.323643,2025-02-10 15:24:12.323739,"{'trace_id': '86007325167544494562106922366787585772', 'parent_id': '1619271752053494628', 'span_id': '3960762505308582189'}"
